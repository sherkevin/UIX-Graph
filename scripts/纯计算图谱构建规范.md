# 纯计算图谱构建规范 (Pure Computational Graph Standard)

**版本**: 2.0

**适用范围**: 故障诊断树、归因分析图谱构建

---

## 1. 设计理念 (Design Philosophy)

本方案采用 **“纯计算图 (Pure Computational Graph)”** 的设计模式。与传统的属性图不同，我们不将计算逻辑（如“或”、“且”、“加和”）隐藏在边的属性中，而是将其**实体化为图中的节点**。

### 1.1 核心原则：一切皆节点 (Everything is a Node)

在我们的图谱中，存在三种“一等公民”节点，它们共同构成了逻辑网络：

1. **实体节点 (Entity Node)**：代表具体的物理对象、故障现象或数据指标（如“上片旋转超限”、“吸盘”）。
2. **算子节点 (Operator Node)**：代表逻辑运算或动作（如 `||`, `&&`, `+`, `Action`）。
3. **虚拟节点 (Virtual Node)**：代表逻辑分组或子系统集合（如 `({12}||{13})` 形成的“WS硬件组”）。

### 1.2 边的纯粹性 (Flow-Only Edges)

边 (Edge) 不再承载任何业务逻辑。

* **边的含义**：仅代表“数据流向”或“影响传递”。
* **结构**：`Source (来源) -> Target (目标)`。
* **优势**：图遍历算法变得极度简洁。无论遇到什么节点，只需顺着边走，遇到算子节点就执行计算，遇到实体节点就读取状态。

### 1.3 逻辑解耦 (Decoupling)

* **可扩展性**：如果未来需要引入新的计算逻辑（例如“加权平均”），只需新增一种类型的**算子节点**，而无需修改数据库 Schema 或边的定义。
* **可视化友好**：前端展示时，复杂的逻辑关系变成了清晰的节点连接，而非线上的晦涩文字。

---

## 2. 编写规范 (Authoring Specifications)

为了确保转换脚本能正确解析，所有输入数据必须严格遵守以下 JSON 格式。

### 2.1 实体定义：`node.json`

用于定义所有基础实体（故障、部件、指标）。

* **Key (ID)**：唯一标识符，建议使用纯数字字符串（如 `"1"`, `"102"`）。**不同含义的节点必须使用不同ID，禁止合并**。
* **Value (属性)**：
* `name` (必填)：节点名称。
* `type` (必填)：节点类型（如 `故障状态`, `数据表征`）。
* `subsystem` (选填)：如果节点属于某子系统（如 WS, WH），在此标注。脚本会将它们自动归纳，**不要**手动创建父级子系统节点。



**示例：**

```json
{
    "1": {
        "name": "cowa拒片",
        "type": "故障状态"
    },
    "12": {
        "name": "docking plate",
        "type": "故障状态",
        "subsystem": "WS" 
    },
    "17": {
        "name": "HWSTGA--上片重复性",
        "type": "数据表征"
    }
}

```

### 2.2 逻辑定义：`compute.json`

用于定义节点之间的计算和推导关系。

* **结构**：每一条规则描述了 **“Target（结果）”** 是如何由 **“Operator（来源表达式）”** 计算得来的。
* **引用语法**：所有引用 `node.json` 中的 ID 时，必须包裹在花括号中，如 `{12}`。
* **分组语法**：使用小括号 `()` 进行逻辑分组。括号内的内容会被自动提取为**虚拟节点**。
* **支持算子**：
* `||` (逻辑或)
* `&&` (逻辑与)
* `+`, `-`, `*`, `/` (算术运算)
* `{do}` (动作前置，如 `{do}{12}` 表示执行12)



**示例：**

```json
{
    "1": {
        "target": "{1}", 
        "operator": "{2}"
        // 含义：节点1 的状态直接来源于 节点2
    },
    "2": {
        "target": "{2}",
        "operator": "{3}||{4}||({12}||{13}||{14})"
        // 含义：节点2 由 3 或 4 或 (12/13/14组成的虚拟组) 导致
        // 系统会自动创建：
        // 1. 虚拟节点 V_10001 代表 (12||13||14)
        // 2. 算子节点 OP_20001 代表 ||
    }
}

```

---

## 3. ID 体系规划 (ID System)

为了保证图谱的清晰，系统在转换时采用分段 ID 策略：

| ID 范围 | 节点类型 | 来源 | 说明 |
| --- | --- | --- | --- |
| **1 - 9999** | **实体节点** | 用户编写 (`node.json`) | 具体的物理/逻辑对象 |
| **10001+** | **虚拟节点** | 自动生成 | 由 `()` 分组生成的中间节点，用于模块化管理 |
| **20001+** | **算子节点** | 自动生成 | 代表 ` |

---

## 4. 转换逻辑示意 (Conversion Logic)

理解转换逻辑有助于您编写更规范的 `compute.json`。

### 场景演示

假设您编写了如下规则：
**`target: "{A}", operator: "{B} || ({C} && {D})"`**

系统将按以下步骤将其转换为图：

1. **解析括号 (虚拟化)**：
* 发现 `({C} && {D})`。
* 创建一个**虚拟节点** `V1`。
* 创建**算子节点** `OP1 (&&)`。
* 建立连接：`C -> OP1 -> V1`, `D -> OP1 -> V1`。


2. **解析外层逻辑 (算子化)**：
* 现在逻辑变成了 `{B} || {V1}`。
* 创建**算子节点** `OP2 (||)`。
* 建立连接：`B -> OP2 -> A`, `V1 -> OP2 -> A`。



### 最终图谱结构图

*(此处为文字描述图示)*

```mermaid
graph LR
    subgraph Entity_Input
    C(实体C)
    D(实体D)
    B(实体B)
    end

    subgraph Virtual_Calculation
    OP1((&& 算子))
    V1[虚拟节点 V1]
    OP2((|| 算子))
    end

    subgraph Entity_Output
    A(实体A)
    end

    C --> OP1
    D --> OP1
    OP1 --> V1
    V1 --> OP2
    B --> OP2
    OP2 --> A

```

---

## 5. 常见问题 (FAQ)

**Q1: 为什么不能直接写 `name` 而要用 `{ID}`？**
A: 使用 ID 可以避免重名问题（例如不同子系统下都有“电源异常”），且在图数据库中 ID 索引效率最高。

**Q2: `{do}` 是什么意思？**
A: `{do}` 是一个特殊的算子。在故障排查中，有时某个节点不是“导致”另一个节点，而是“动作前置”（例如：必须先执行“读取日志”，才能获取“日志数据”）。写作 `{do}{12}` 会生成一个 `Action` 类型的算子节点。

**Q3: 边的方向为什么是反的？**
A: 在编写 `compute.json` 时，我们习惯写 `Target = f(Source)`。在生成的图谱中，边的方向是 `Source -> Target`，这代表**数据的流动方向**（故障从底层传播到顶层），符合根因分析算法的需求。